"""Creates single plots of data stored in CDFs or CSVs

This module aims to quickly produce publication quality plots using data
stored in CDF files generated by TRANSP, or CSV files generated by MMM
Explorer.  Various rules have been written that automate the majority of the
plotting process, including exactly what data appears in the title, labels,
and legend.  The user may override any of these rules by specifying their
corresponding parameters in the PlotSettings class.

Variable data loaded from a CDF or CSV is stored using the Variable class
within the either the InputVariables or OutputVariables, where variable
attributes such as label names and symbols are defined here.  Additionally,
the InputControls class also stores data in CSVs pertaining to control
values.  This means that a new Variable object needs to be created in
variables.py if the user wishes to plot any variables not already declared in
either InputVariables or OutputVariables.  Likewise, new Control objects will
need to be created in controls.py if needed.

An example of how to use this module has been provided below, but please refer
to both the PlotSettings and PlotData classes for a full list of parameters
that can be specified when creating plots.

Example Usage:
    * Plot of Electron Temperature and Ion Temperature (vs rho):

        all_data = AllPlotData(
                PlotData(runid='129041A10', yname='te', time=0.50),
                PlotData(runid='129041A10', yname='ti', time=0.50),
        )

        # Note that the runid and time value will automatically appear in the
        # title of the plot, since all PlotData objects share the same values
        # for these attributes.  If instead we use different attribute values
        # such as:

        all_data = AllPlotData(
                PlotData(runid='138536A01', yname='te', time=0.75),
                PlotData(runid='129041A10', yname='ti', time=0.50),
        )

        # Then both the runid and time values will instead appear in the
        # legend for each variable.
"""

# Standard Packages
import sys; sys.path.insert(0, '../')
from dataclasses import dataclass
import logging

# 3rd Party Packages
import matplotlib.pyplot as plt
import numpy as np

# Local Packages
import modules.options
import modules.constants as constants
import modules.controls as controls
import modules.datahelper as datahelper
import modules.variables as variables
import modules.utils as utils
from modules.enums import SaveType
from plotting.modules.plotstyles import PlotStyles, StyleType


_log = logging.getLogger(__name__)


@dataclass
class PlotSettings:
    """
    Settings to control various behaviors of the plot

    Parameters (all Optional):
    * replace_offset_text (bool): If the offset axes text should be put in the axes labels
    * allow_title_runid (bool): If the runid is allowed to appear in the title
    * allow_title_time (bool): If the time is allowed to appear in the title
    * allow_title_rho (bool): If the rho value is allowed to appear in the title
    * allow_title_factor (bool): If the scan factor is allowed to appear in the title
    * title_override (str): Overrides auto generated title if non-empty
    * ylabel_override (str): Overrides auto generated ylabel if non-empty
    * xlabel_override (str): Overrides auto generated xlabel if non-empty
    * xpad (int): The percentage to pad the xaxis limits in each direction
    * ypad (int): The percentage to pad the yaxis limits in each direction
    """

    replace_offset_text: bool = True
    allow_title_runid: bool = True
    allow_title_time: bool = True
    allow_title_rho: bool = True
    allow_title_factor: bool = True
    title_override: str = ''
    ylabel_override: str = ''
    xlabel_override: str = ''
    xpad: int = 0
    ypad: int = 0


class PlotData:
    """
    Contains data to be plotted

    This class is meant to be inherited by either PlotDataCdf or PlotDataCsv

    Parameters:
    * options (Options): Object containing user options
    * runid (str): The runid of the CDF
    * yvar (Variable): The Variable object of the y-variable to plot
    * xvar (Variable): The Variable object of the x-variable to plot
    * factor_symbol (str | None): The symbol of the scanned variable (Optional)
    * scan_factor (str | None): The scan factor value to plot (Optional)
    * rho_value (str | None): The rho value to plot (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend_override (str): A string to completely replace the legend label of a y-variable (Optional)
    """

    def __init__(self, options, runid, yvar, xvar,
                 factor_symbol=None, scan_factor=None, rho_value=None, runname='', legend_override=''):
        self.xvals: np.ndarray = self._unpack_values(xvar.values, options.time_idx)
        self.yvals: np.ndarray = self._unpack_values(yvar.values, options.time_idx)
        self.xsymbol: str = xvar.label
        self.ysymbol: str = yvar.label
        self.xunits: str = xvar.units_label
        self.yunits: str = yvar.units_label
        self.xname: str = xvar.name
        self.yname: str = yvar.name
        self.time: str = options.time_str
        self.runid: str = runid
        self.runname: str = runname
        self.rho: str | None = rho_value
        self.factor: str | None = scan_factor
        self.factor_symbol: str | None = factor_symbol
        self.legend_override: str = legend_override

    @staticmethod
    def _unpack_values(values, time_idx):
        """Returns (np.ndarray): Variable values to be plotted"""
        return values[:, time_idx] if isinstance(values, np.ndarray) and values.ndim == 2 else values

    def get_legend_label(self, legend_attrs):
        """
        Get the y-variable label for the plot legend

        If the legend override is set, then that value is used for the legend
        label.  Otherwise, either the y-variable symbol, the runname (if set) or
        runid, and the time value may be added to the legend.  Each of these
        attributes are only added to the legend if multiple y-variables have
        different values for a given attribute.

        Parameters:
        * legend_attrs (LegendAttributes): Object containing legend attributes

        Returns:
        * (str): The legend label for the variable
        """

        # TODO: Show ysymbol vs xsymbol when xsymbols are different
        if self.legend_override:
            return self.legend_override

        legend_items = []
        if legend_attrs.show_ysymbol:
            legend_items.append(self.ysymbol)
        if legend_attrs.show_runid or legend_attrs.show_runname:
            legend_items.append(self.runname or self.runid)
        if legend_attrs.show_time:
            legend_items.append(f'{self.time}s')
        if legend_attrs.show_rho and self.rho is not None:
            legend_items.append(fr'$\rho = ${self.rho}')
        if legend_attrs.show_factor and self.factor is not None:
            legend_items.append(fr'${self.factor}\,${self.factor_symbol}')

        return' '.join(legend_items)


class PlotDataCdf(PlotData):
    """
    Load data from a CDF to be plotted

    The names of the x-variable and y-variable must match member definitions
    in the InputVariables class.  For example, InputVariables contains the
    member definition 'self.te', corresponding to Electron Temperature, so
    that variable should be referenced using 'te' as the name here.  See
    variables.py for a full list of variables defined in the InputVariables
    class.

    Parameters:
    * runid (str): The runid of the CDF
    * time (float): The time value to plot
    * yname (str): The name of the y-variable to plot
    * xname (str): The name of the x-variable to plot (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend_override (str): A string to completely replace the legend label of a y-variable (Optional)
    * use_cdf_vars (bool): Uses uncalculated CDF variables instead of calculated MMM variables (Optional)
    """

    def __init__(self, runid, time, yname, xname='rho', runname='', legend_override='', use_cdf_vars=False):
        options = modules.options.Options(runid=runid, input_time=time)
        mmm_vars, cdf_vars, __ = datahelper.initialize_variables(options)
        plot_vars = mmm_vars if not use_cdf_vars else cdf_vars

        yvar = getattr(plot_vars, yname)
        xvar = getattr(plot_vars, xname)

        super().__init__(options, runid, yvar, xvar,
                         runname=runname, legend_override=legend_override)


class PlotDataCsv(PlotData):
    """
    Load data from a CSV to be plotted

    The names of the x-variable and y-variable must match member definitions
    in the InputVariables class.  For example, InputVariables contains the
    member definition 'self.te', corresponding to Electron Temperature, so
    that variable should be referenced using 'te' as the name here.  See
    variables.py for a full list of variables defined in the InputVariables
    class.

    Parameters:
    * runid (str): The runid of the CSV
    * scan_num (int): The scan number of the CSV
    * yname (str): The name of the y-variable to plot
    * xname (str): The name of the x-variable to plot (Optional)
    * scan_factor (float): The scan factor of the CSV to load (Optional)
    * rho_value (float): The rho value of the CSV to load (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend_override (str): A string to completely replace the legend label of a y-variable (Optional)
    """

    def __init__(self, runid, scan_num, yname, xname='rho',
                 scan_factor=None, rho_value=None, runname='', legend_override=''):
        options = modules.options.Options().load(runid, scan_num)
        input_vars = variables.InputVariables(options)
        output_vars = variables.OutputVariables(options)
        input_controls = controls.InputControls(options)
        scan_factor_str = None

        if rho_value and scan_factor:
            _log.warning(f'PlotDataCsv:\n\tscan_factor is not used when rho_value is specified')
            scan_factor = None

        if rho_value:
            rho_value = utils.get_closest_rho(options, SaveType.INPUT, rho_value)

        if scan_factor:
            scan_factor = options.find_scan_factor(scan_factor)
            scan_factor_str = f'{scan_factor:{constants.SCAN_FACTOR_DISPLAY_FMT}}'

        adjusted_var = options.get_adjusted_var()

        input_vars.load_from_csv(SaveType.INPUT, scan_factor, rho_value)
        input_vars.load_from_csv(SaveType.ADDITIONAL, scan_factor, rho_value)
        output_vars.load_from_csv(SaveType.OUTPUT, scan_factor, rho_value)
        input_controls.load_from_csv(use_rho=True)

        data_objects = [input_vars, output_vars, input_controls]
        yvar = xvar = fvar = None
        for o in data_objects:
            if not yvar and hasattr(o, yname):
                yvar = getattr(o, yname)
            if not xvar and hasattr(o, xname):
                xvar = getattr(o, xname)
            if not fvar and hasattr(o, adjusted_var):
                fvar = getattr(o, adjusted_var)

        super().__init__(options, runid, yvar, xvar, factor_symbol=fvar.label, scan_factor=scan_factor_str,
                         rho_value=rho_value, runname=runname, legend_override=legend_override)


class AllPlotData:
    """
    Store all individual PlotData objects

    Parameters:
    * args (tuple[PlotData]): Contains PlotData objects to store
    """

    def __init__(self, *args):
        self.data: list[PlotData] = [a for a in args if isinstance(a, PlotData)]

    @staticmethod
    def _format_offset_text(offset_text):
        """
        Format the offset text for each axis

        Offset text is generated by MatPlotLib and is usually just the
        exponent '\\times 10^{n}' that can appear for each axis.  This offset
        text can also contain an additive term however, which happens when
        the values being plotted change by a very small amount around a value
        that's not nearly 0.  For example, if values ranged from 2 + 1e-6 to
        2 + 2e-6, then an additive term of +2 would appear in the offset
        text.

        Parameters:
        * offset_text (str): The offset text of the axis

        Returns:
        * (str): The formatted offset text
        """

        if not offset_text:
            return offset_text

        if '+' in offset_text:
            number_str = offset_text.split('+')[1].split('}')[0]
            number = f'{float(number_str):.12g}'
            offset_text = offset_text.replace(number_str, number)

        return f' {offset_text}'

    def get_legend_include(self, attr_name):
        """
        Determine if a legend attribute should be included in the legend

        The rule for adding an attribute to the legend is if multiple plotted
        variables have different values for a checked attribute.  For example, if
        var A and var B both have different runid's, then their runid's are added
        to the legend.  If there is only one variable to plot, then no attributes
        will be added to the legend.

        Parameters:
        * attr_name (str): The name of a LegendAttributes member

        Returns:
        * (bool) True if the attribute should be added to the legend
        """

        attrs = set()
        for pdata in self.data:
            attrs.add(getattr(pdata, attr_name))

        return len(attrs) > 1

    def get_plot_limits(self, plot_settings):
        """
        Get the limits of the plot, adjusted by padding parameters set in plot settings

        The axes limits are adjusted by the percentage given for xpad and ypad
        in the plot settings object, in each direction for either axis.  For
        example, if ypad = 1, then the limits of the yaxis are both increased
        and decreased by 1%.  Note that MatPlotLib uses default padding of
        something like 5% on each axis, so setting padding values smaller
        than this value will produce tighter plots than what would be created
        if the padding wasn't adjusted.

        Parameters:
        * plot_settings (PlotSettings): Plot settings object

        Returns:
        * (tuple[float]): The xlims of the plot
        * (tuple[float]): The ylims of the plot
        """

        xpad = plot_settings.xpad / 100  # Convert from percentage to number
        ypad = plot_settings.ypad / 100

        xmin = ymin = float("inf")
        xmax = ymax = -float("inf")
        for pdata in self.data:
            xmin = min(xmin, pdata.xvals.min())
            xmax = max(xmin, pdata.xvals.max())
            ymin = min(ymin, pdata.yvals.min())
            ymax = max(ymax, pdata.yvals.max())

        xoffset = (xmax - xmin) * xpad
        yoffset = (ymax - ymin) * ypad

        xmin -= xoffset
        xmax += xoffset
        ymin -= yoffset
        ymax += yoffset

        # Default limits when min equals max
        if xmin == xmax:
            xmin = -xpad
            xmax = 1 + xpad
        if ymin == ymax:
            ymin = -ypad
            ymax = 1 + ypad

        return (xmin, xmax), (ymin, ymax)

    def get_plot_title(self, plot_settings, legend_attrs):
        """
        Get the title for the plot

        If the title override is set, then the title override value is used
        for the title of the plot.

        If there is no title override, then a title is generated from the
        intersection of all words in the names of the y-variables being
        plotted.

        Title details are added when all variables share the same value of the
        corresponding attribute.  Possible details are: runid, time, scan
        factor, rho value.

        Parameters:
        * plot_settings (PlotSettings): Plot settings object
        * legend_attrs (LegendAttributes): Legend data object

        Returns:
        * (str): The title for the plot
        """

        base_title = plot_settings.title_override or self._generate_unique_title()
        title_details = self._get_title_details(plot_settings, legend_attrs)

        return f'{base_title}{title_details}'

    def _generate_unique_title(self):
        """
        Generate a title by taking the intersection of all words that appear
        in the name of each y-variable being plotted.

        Example 1:
            name1 = 'Thermal Ion Density'
            name2 = 'Deuterium Ion Density'

            >>> The generated title would be 'Ion Density', since both of
                these words are in each name.

        Example 2:
            name1 = 'Thermal Ion Density'
            name2 = 'Deuterium Ion Density'
            name3 = 'Electron Density'

            >>> The generated title would be 'Density', since this is the only
                word that is in each name.

        Note that the title will be blank if the intersection of all words is
        empty.

        Returns:
        * (str): The unique title for the plot
        """

        unique_ynames = set([data.yname for data in self.data])
        first_name_words = self.data[0].yname.split()
        title_words = []

        # Form list of title words for words that appear in the first y-variable name
        for word in first_name_words:
            append_word = True
            for name in unique_ynames:
                if word not in name:
                    append_word = False
                    break
            if append_word:
                title_words.append(word)

        return ' '.join(title_words)

    def _get_title_details(self, plot_settings, legend_attrs):
        """
        Get the title details

        Details are added to the title if the corresponding title details
        switch is enabled and all variables share the same value for that
        attribute. Possible title details include the runid, time, and rho
        value for each plotted variable.  For example, if all plotted
        variables share the same runid, then the runid is added to the
        title.

        Parameters:
        * plot_settings (PlotSettings): Plot settings object
        * legend_attrs (LegendAttributes): Legend data object

        Returns:
        * (str): The details to add to the title
        """

        title_details_list = []
        allow_runid = plot_settings.allow_title_runid
        allow_time = plot_settings.allow_title_time
        allow_rho = plot_settings.allow_title_rho
        allow_factor = plot_settings.allow_title_factor

        if allow_runid or allow_time or allow_rho:
            var = self.data[0]  # use first variable values for title details (same for all variables)

            if allow_runid and not (legend_attrs.show_runid or legend_attrs.show_runname):
                # all lines have same runid or runname
                title_details_list.append(var.runname or var.runid)
            if allow_time and not legend_attrs.show_time:
                # all lines have same time
                title_details_list.append(f'{var.time}s')
            if allow_rho and not legend_attrs.show_rho and var.rho is not None:
                # all lines have same rho, and rho is not None
                title_details_list.append(fr'$\rho = ${var.rho}')
            if allow_factor and not legend_attrs.show_factor and var.factor is not None:
                title_details_list.append(fr'${var.factor}\,${var.factor_symbol}')

        return f' ({", ".join(title_details_list)})' if title_details_list else ''

    def get_plot_ylabel(self, plot_settings, legend_attrs, offset_text):
        """
        Get the yaxis label for the plot

        If the ylabel override is set, then that is used for the ylabel of the
        plot.  Otherwise, the unique units of each y-variable are added to the
        ylabel (the same units aren't repeated).  Additionally, if the y-variable
        symbols do not appear in the legend, then these unique symbols are also
        added to the ylabel.

        Parameters:
        * plot_settings (PlotSettings): Plot settings object
        * legend_attrs (LegendAttributes): Legend data object
        * offset_text (str): The offset text from the y-axis of the plot

        Returns:
        * (str): The ylabel for the plot
        """

        offset_text = self._format_offset_text(offset_text)

        if plot_settings.ylabel_override:
            return f'{plot_settings.ylabel_override}{offset_text}'

        ylabels = []  # Not using a set to preserve order
        for d in self.data:
            if not legend_attrs.show_ysymbol:  # ysymbol is not in the legend
                ystr = f'{d.ysymbol} {d.yunits}'
                if ystr not in ylabels:
                    ylabels.append(ystr)
            elif d.yunits not in ylabels:  # ysymbol is in the legend
                ylabels.append(d.yunits)

        joined_labels = '   '.join(ylabels)
        return f'{joined_labels}{offset_text}'

    def get_plot_xlabel(self, plot_settings, legend_attrs, offset_text):
        """
        Get the xaxis label for the plot

        If the xlabel override is set, then that is used for the xlabel of the
        plot.  Otherwise, the unique symbols and units of each x-variable are
        added to the ylabel (the same units aren't repeated).

        Parameters:
        * plot_settings (PlotSettings): Plot settings object
        * legend_attrs (LegendAttributes): Legend data object
        * offset_text (str): The offset text from the x-axis of the plot

        Returns:
        * (str): The xlabel for the plot
        """

        offset_text = self._format_offset_text(offset_text)

        if plot_settings.xlabel_override:
            return f'{plot_settings.xlabel_override}{offset_text}'

        xlabels = []  # Not using a set to preserve order
        for d in self.data:
            xstr = f'{d.xsymbol} {d.xunits}'
            if xstr not in xlabels:
                xlabels.append(xstr)

        joined_labels = '   '.join(xlabels)
        return f'{joined_labels}{offset_text}'


class LegendAttributes:
    """
    Store a bool for whether each attribute should appear in the legend

    Parameters:
    * ysymbol (bool): True if the y-variable symbol should be shown in the legend
    * runid (bool): True if the runid should be shown in the legend
    * runname (bool): True if the runname should be shown in the legend
    * time (bool): True if the time value should be shown in the legend
    * factor (bool): True if the scan factor should be shown in the legend
    * override (bool): True if legend overrides have been specified
    """

    def __init__(self, ysymbol, runid, runname, time, rho, factor, override):
        self.show_ysymbol: bool = ysymbol
        self.show_runid: bool = runid
        self.show_runname: bool = runname
        self.show_time: bool = time
        self.show_rho: bool = rho
        self.show_factor: bool = factor
        self.show_override: bool = override

    def show_legend(self):
        """Returns (bool): True if the legend should be shown"""

        show_legend = False
        attributes = self.get_attributes()
        for a in attributes:
            if getattr(self, a):
                show_legend = True
                break
        return show_legend

    def get_attributes(self):
        """Returns (list[str]): all boolean legend attributes"""
        return [a for a in dir(self) if isinstance(getattr(self, a), bool)]


def main(plot_settings, all_data):
    """
    Create a plot using data loaded from CDF files

    Parameters:
    * plot_settings (PlotSettings): Object containing plot settings
    * all_data (AllPlotData): Object containing all PlotData objects
    """

    ax = plt.gca()

    legend_attrs = LegendAttributes(
        ysymbol=all_data.get_legend_include('ysymbol'),
        runid=all_data.get_legend_include('runid'),
        runname=all_data.get_legend_include('runname'),
        time=all_data.get_legend_include('time'),
        rho=all_data.get_legend_include('rho'),
        factor=all_data.get_legend_include('factor'),
        override=all_data.get_legend_include('legend_override')
    )

    for d in all_data.data:
        ax.plot(d.xvals, d.yvals, label=d.get_legend_label(legend_attrs))

    xlims, ylims = all_data.get_plot_limits(plot_settings)

    ax.set(xlim=xlims, ylim=ylims)

    offset_text_x = offset_text_y = ''
    if plot_settings.replace_offset_text:
        plt.gcf().canvas.draw()  # needed to grab offsetText string
        ax.xaxis.offsetText.set_visible(False)
        ax.yaxis.offsetText.set_visible(False)
        offset_text_x = ax.xaxis.offsetText._text
        offset_text_y = ax.yaxis.offsetText._text

    ax.set(
        title=all_data.get_plot_title(plot_settings, legend_attrs),
        xlabel=all_data.get_plot_xlabel(plot_settings, legend_attrs, offset_text_x),
        ylabel=all_data.get_plot_ylabel(plot_settings, legend_attrs, offset_text_y),
    )

    if legend_attrs.show_legend():
        ax.legend().set_draggable(state=True)

    plt.show()


if __name__ == '__main__':
    """
    Run this module directly to plot variable data stored in CDF files.
    AllPlotData can contain both plot data from a CDF (PlotDataCdf) and from
    a CSV (PlotDataCsv).

    * AllPlotData loaded from a CDF:
        all_data = AllPlotData(
            PlotDataCdf(runid='138536A01', yname='ne', xname='rho', time=0.50),
            PlotDataCdf(runid='138536A01', yname='ni', xname='rho', time=0.50,),
        )

    * AllPlotData loaded from a CSV (using a scan factor):
        all_data = AllPlotData(
            PlotDataCsv(runid='138536A01', yname='ti', xname='rho', scan_num=1, scan_factor=2),
            PlotDataCsv(runid='138536A01', yname='te', xname='rho', scan_num=1, scan_factor=2),
        )

    * AllPlotData loaded from a CSV (using a rho value):
        all_data = AllPlotData(
            PlotDataCsv(runid='138536A01', yname='gmaETGM', xname='etgm_kyrhos', scan_num=3, rho_value=0.2),
            PlotDataCsv(runid='138536A01', yname='omgETGM', xname='etgm_kyrhos', scan_num=3, rho_value=0.2),
        )
    """

    utils.init_logging()

    # Define visual styles for the plot
    PlotStyles(
        axes=StyleType.Axes.GRAY,
        lines=StyleType.Lines.MMM,
        layout=StyleType.Layout.SINGLE,
    )

    # Define settings for the plot
    plot_settings = PlotSettings(
        replace_offset_text=True,
        allow_title_runid=True,
        allow_title_time=True,
        allow_title_rho=True,
        allow_title_factor=True,
        title_override='',
        ylabel_override='',
        xlabel_override='',
        ypad=1,
        xpad=0,
    )

    # Define data for the plot
    all_data = AllPlotData(
        # PlotDataCdf(runid='138536A01', yname='ne', xname='rho', time=0.50, runname=''),
        # PlotDataCdf(runid='138536A01', yname='ni', xname='rho', time=0.50, runname=''),
        # PlotDataCsv(runid='138536A01', yname='te', xname='rho', scan_num=2, scan_factor=2, runname=''),
        # PlotDataCsv(runid='138536A01', yname='ti', xname='rho', scan_num=2, scan_factor=2, runname=''),
        PlotDataCsv(runid='138536A01', yname='gmaETGM', xname='zeff', scan_num=2, rho_value=0.2, runname=''),
        PlotDataCsv(runid='138536A01', yname='omgETGM', xname='zeff', scan_num=2, rho_value=0.2, runname=''),
    )

    main(plot_settings, all_data)
