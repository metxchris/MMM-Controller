#!/usr/bin/python3

"""Creates single plots of data stored in CDFs or CSVs

This module aims to quickly produce publication quality plots using data
stored in CDF files generated by TRANSP, or CSV files generated by MMM
Explorer.  Various rules have been written that automate the majority of the
plotting process, including exactly what data appears in the title, labels,
and legend.  The user may override any of these rules by specifying their
corresponding parameters in the PlotSettings class.

Variable data loaded from a CDF or CSV is stored using the Variable class
within the either the InputVariables or OutputVariables, where variable
attributes such as label names and symbols are defined here.  Additionally,
the InputControls class also stores data in CSVs pertaining to control
values.  This means that a new Variable object needs to be created in
variables.py if the user wishes to plot any variables not already declared in
either InputVariables or OutputVariables.  Likewise, new Control objects will
need to be created in controls.py if needed.

Examples of how to use this module has been provided at the bottom of this
file, but please refer to both the PlotSettings and PlotData classes for a
full list of parameters that can be specified when creating plots.
"""

# Standard Packages
import sys; sys.path.insert(0, '../')
import logging
import io

# 3rd Party Packages
import matplotlib.pyplot as plt
import numpy as np
from PyQt5.QtGui import QImage
from PyQt5.QtWidgets import QApplication

# Local Packages
import modules.options
import modules.constants as constants
import modules.datahelper as datahelper
import modules.utils as utils
from modules.enums import SaveType
from plotting.modules.plotstyles import PlotStyles, StyleType


_log = logging.getLogger(__name__)


class PlotData:
    """
    Contains data to be plotted

    This class is meant to be inherited by either PlotDataCdf or PlotDataCsv

    Parameters:
    * options (Options): Object containing user options
    * runid (str): The runid of the CDF
    * yname (str): The name of the y-variable to plot
    * xname (str): The name of the x-variable to plot
    * yvar (Variable): The Variable object of the y-variable to plot
    * xvar (Variable): The Variable object of the x-variable to plot
    * zidx (int):
    * timeplot (bool):
    * yval_base (list[float]): The base y-variable value when plotting at a rho point (Optional)
    * xval_base (list[float]): The base x-variable value when plotting at a rho point (Optional)
    * xmult (float): Multiplier to apply to the xvar values (Optional)
    * ymult (float): Multiplier to apply to the yvar values (Optional)
    * source (str): The data source = 'mmm', 'cdf', 'raw' (Optional)
    * is_cdf (bool): If the data source is loaded from a CDF (Optional)
    * is_csv (bool): If the data source is loaded from a CSV (Optional)
    * factor_symbol (str | None): The symbol of the scanned variable (Optional)
    * scan_factor (str | None): The scan factor value to plot (Optional)
    * rho_value (str | None): The rho value to plot (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend (str): A string to replace the auto generated legend label of a y-variable (Optional)

    Raises:
    * ValueError: If values for the x-variable or y-variable are None
    """

    def __init__(self, options, runid, yname, xname, yvar, xvar, zidx, zval,
                 timeplot=False, yval_base=None, xval_base=None, source='mmm',
                 is_cdf=False, is_csv=False, factor_symbol=None, scan_factor=None,
                 ymult=1, xmult=1, rho_value=None, runname='', legend=''):

        self.options = options
        self.timeplot = timeplot
        self.xmult: float = xmult
        self.ymult: float = ymult
        self.xvals: np.ndarray = self._get_values(xvar, zidx) * xmult
        self.yvals: np.ndarray = self._get_values(yvar, zidx) * ymult
        self.xval_base: list[float] = xval_base or []  # plotting an empty list advances the cycler
        self.yval_base: list[float] = yval_base or []
        self.xsymbol: str = xvar.label
        self.ysymbol: str = yvar.label
        self.xunits: str = xvar.units_label
        self.yunits: str = yvar.units_label
        self.xvarname: str = xvar.name
        self.yvarname: str = yvar.name
        self.xname: str = xname
        self.yname: str = yname
        self.time: str = options.time_str
        self.zval: float = zval
        self.runid: str = runid
        self.runname: str = runname
        self.rho: str | None = rho_value
        self.factor: str | None = scan_factor
        self.factor_symbol: str | None = factor_symbol
        self.legend: str = legend
        self.source: str = source
        self.is_cdf: bool = is_cdf
        self.is_csv: bool = is_csv
        self.scan_range = options.scan_range

        # self.xvals = np.absolute(self.xvals)
        # self.xval_base = [abs(b) for b in self.xval_base]

        if self.xvals is None:
            raise ValueError(f'Unable to load values for variable {xvar.name}')
        if self.yvals is None:
            raise ValueError(f'Unable to load values for variable {yvar.name}')

    def _get_values(self, var, zidx):
        """Returns (np.ndarray): Variable values to be plotted"""
        if not self.timeplot:
            values = var.values[:, zidx] if isinstance(var.values, np.ndarray) and var.values.ndim == 2 else var.values
        else:
            values = var.values[zidx, :] if isinstance(var.values, np.ndarray) and var.values.ndim == 2 else var.values
        # values = var.values
        # print(var.name, var.values.shape, values.shape)
        if values is None:
            raise ValueError(f'Null values detected for variable name {var.name}')
        return values

    def get_ysymbol_label_str(self):
        """Returns (str): The ysymbol string used in the legend label"""
        return self.ysymbol

    def get_xsymbol_label_str(self):
        """Returns (str): The xsymbol string used in the legend label"""
        return fr'{self.ysymbol}$\,$({self.xsymbol})'

    def get_run_label_str(self):
        """Returns (str): The runname or runid string used in the legend label and title details"""
        return self.runname or self.runid

    def get_time_label_str(self):
        """Returns (str): The time string used in the legend label and title details"""
        return f'{self.time}s' if self.time else ''

    def get_rho_label_str(self):
        """Returns (str): The rho string used in the legend label and title details"""
        return fr'$\rho = ${self.rho}'

    def get_factor_label_str(self):
        """Returns (str): The factor string used in the legend label and title details"""
        no_factor = not self.factor_symbol or self.factor is None
        return r'$\mathtt{Base}$' if no_factor else fr'${self.factor}\cdot${self.factor_symbol}'

    def get_calc_source_str(self):
        """Returns (str): The data source string used in the legend label"""
        return r'$\mathtt{TRANSP}$' if self.source != 'mmm' else r'$\mathtt{MMM}$'

    def get_data_source_str(self):
        """Returns (str): The data source string used in the legend label"""
        return r'$\mathtt{CDF}$' if self.is_cdf else r'$\mathtt{CSV}$' if self.is_csv else ''

    def get_zval_str(self):
        """Returns (str): The zval string used in the legend label"""
        return fr'{self.zval}s' if not self.timeplot else fr'$\rho = {self.zval}$'


class PlotDataCdf(PlotData):
    """
    Load data from a CDF to be plotted

    The names of the x-variable and y-variable must match member definitions
    in the InputVariables class.  For example, InputVariables contains the
    member definition 'self.te', corresponding to Electron Temperature, so
    that variable should be referenced using 'te' as the name here.  See
    variables.py for a full list of variables defined in the InputVariables
    class.

    Parameters:
    * runid (str): The runid of the CDF
    * zval (float): The time or rho value to plot
    * yname (str): The name of the y-variable to plot
    * xname (str): The name of the x-variable to plot (Optional)
    * timeplot (bool): True if plotting time on the x-axis (Optional)
    * xmult (float): Multiplier to apply to the xvar values (Optional)
    * ymult (float): Multiplier to apply to the yvar values (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend (str): A string to replace the auto generated legend label of a y-variable (Optional)
    * source (str): The data source = 'mmm', 'cdf', 'raw' (Optional)
    * input_points (int): the amount of radial points each variable is interpolated to when sent to MMM (Optional)
    * apply_smoothing (bool): kill-switch to disable smoothing of all variables (Optional)
    """

    def __init__(self, runid, zval, yname, xname=None, timeplot=False, runname='', legend='', source='mmm',
                 input_points=None, apply_smoothing=False, ymult=1, xmult=1):
        input_time = zval if not timeplot else None
        options = modules.options.Options(
            runid=runid, input_time=input_time, input_points=input_points,
            ignore_exceptions=True, apply_smoothing=apply_smoothing
        )
        mmm_vars, cdf_vars, raw_vars = datahelper.initialize_variables(options)

        if xname is None:
            xname = 'rho' if not timeplot else 'time'

        if source == 'mmm':
            plot_vars = mmm_vars
        elif source == 'cdf':
            plot_vars = cdf_vars
        elif source == 'raw':
            plot_vars = raw_vars
        else:
            raise ValueError(f'{source} is not a valid source value (use source = mmm, cdf, or raw)')

        yvar = getattr(plot_vars, yname)
        xvar = getattr(plot_vars, xname)

        # Get the zidx (index of the time or rho value)
        if timeplot:
            zidx = np.argmin(np.abs(plot_vars.rho.values[:, 0] - zval))
            zval = plot_vars.rho.values[zidx, 0]
        else:
            zidx = options.time_idx
            zval = options.time_str

        super().__init__(
            options, runid, yname, xname, yvar, xvar, zidx, zval,
            timeplot=timeplot, source=source, is_cdf=True,
            runname=runname, legend=legend, ymult=ymult, xmult=xmult
        )


class PlotDataCsv(PlotData):
    """
    Load data from a CSV to be plotted

    The names of the x-variable and y-variable must match member definitions
    in the InputVariables class.  For example, InputVariables contains the
    member definition 'self.te', corresponding to Electron Temperature, so
    that variable should be referenced using 'te' as the name here.  See
    variables.py and controls.py for a full list of InputVariables,
    OutputVariables, and InputControls members that can be referenced by
    name.

    Parameters:
    * runid (str): The runid of the CSV
    * scan_num (int): The scan number of the CSV
    * yname (str): The name of the y-variable to plot
    * xname (str): The name of the x-variable to plot (Optional)
    * timeplot (bool): True if plotting time on the x-axis (Optional)
    * xmult (float): Multiplier to apply to the xvar values (Optional)
    * ymult (float): Multiplier to apply to the yvar values (Optional)
    * scan_factor (float): The scan factor of the CSV to load (Optional)
    * rho_value (float): The rho value of the CSV to load (Optional)
    * runname (str): A string to replace the runid that shows in plot legends or titles (Optional)
    * legend (str): A string to replace the auto generated legend label of a y-variable (Optional)
    """

    def __init__(self, runid, scan_num, yname, xname='rho', ymult=1, xmult=1,
                 scan_factor=None, rho_value=None, runname='', legend=''):

        options = modules.options.Options().load(runid, scan_num)
        scan_factor_str = None

        timeplot = True if options.var_to_scan == 'time' else False

        if xname == 'var_to_scan':
            xname = options.var_to_scan

        rho_str = None
        if rho_value is not None:
            rho_str = utils.get_closest_rho(options, SaveType.OUTPUT, rho_value) if rho_value is not None else ''

        elif scan_factor:
            scan_factor = options.find_scan_factor(scan_factor)
            scan_factor_str = f'{scan_factor:{constants.SCAN_FACTOR_DISPLAY_FMT}}'

        yvar, xvar, factor_symbol = self._get_vars_from_data(options, scan_factor, rho_str, yname, xname)
        yval_base, xval_base = self._get_base_values_from_data(options, rho_str, yname, xname)

        # Get the zidx (index of the time or rho value)
        if timeplot:
            zidx = np.argmin(np.abs(options.scan_range - rho_value))
            zval = rho_value
        else:
            zidx = options.time_idx
            zval = options.time_str

        super().__init__(
            options, runid, yname, xname, yvar, xvar, zidx, zval,
            timeplot=timeplot, factor_symbol=factor_symbol, is_csv=True,
            yval_base=yval_base, xval_base=xval_base, rho_value=rho_str,
            scan_factor=scan_factor_str, runname=runname, legend=legend,
            ymult=ymult, xmult=xmult
        )

    @staticmethod
    def _get_vars_from_data(options, scan_factor, rho_value, yname, xname):
        """
        Get the x- and y- variables, along with the symbol of the scan factor
        (if applicable)

        Parameters:
        * options (Options): Object containing user options
        * scan_factor (float): The scan factor to load
        * rho_value (str): The rho value to load
        * yname (str): The name of the y-variable to plot
        * xname (str): The name of the x-variable to plot

        Returns:
        * yvar (Variable): The Variable object of the y-variable to plot
        * xvar (Variable): The Variable object of the x-variable to plot
        * factor_symbol (str | None): The symbol of the scanned variable

        Raises:
        * NameError: If xname or yname cannot be found in the data objects
        """

        yvar = xvar = factor_symbol = None
        adjusted_var = options.var_to_scan
        ivars, ovars, ctrls = datahelper.get_data_objects(options, scan_factor, rho_value)
        data_objects = [ovars, ivars, ctrls]

        for o in data_objects:
            if not yvar and hasattr(o, yname):
                yvar = getattr(o, yname)
            if not xvar and hasattr(o, xname):
                xvar = getattr(o, xname)
            if scan_factor and not factor_symbol and adjusted_var and hasattr(o, adjusted_var):
                factor_symbol = getattr(o, adjusted_var).label

        if not yvar or not xvar:
            raise NameError(
                f'One of the variables "{xname}" or "{yname}" is not specified in '
                f'InputVariables, OutputVariables, or InputControls (typo?)'
            )

        return yvar, xvar, factor_symbol

    @staticmethod
    def _get_base_values_from_data(options, rho_value, yname, xname):
        """
        Get the base value of the x- and y- variables, when using a rho value

        Parameters:
        * options (Options): Object containing user options
        * rho_value (str): The rho value to load
        * yname (str): The name of the y-variable to plot
        * xname (str): The name of the x-variable to plot

        Returns:
        * yval_base (list[float]): The base value of the y-variable
        * xval_base (list[float]): The base value of the x-variable

        Raises:
        * ValueError: If the rho value cannot be found in the rho folder
        """

        yval_base = xval_base = None

        if rho_value is not None:
            rho_strs = np.array(utils.get_rho_strings(options, SaveType.OUTPUT), dtype=str)
            base_value_idx_list = np.where(rho_strs == rho_value)

            if not len(base_value_idx_list):
                raise ValueError(
                    f'The rho value {rho_value} does not match any files saved in the rho folder'
                    f'\n\tAvailable files:'
                    f'\n\t{rho_strs}'
                )

            base_value_idx = base_value_idx_list[0][0]
            data_objects = list(datahelper.get_data_objects(options))

            for o in data_objects:
                if not yval_base and hasattr(o, yname):
                    yval_base = [getattr(o, yname).values[base_value_idx]]
                if not xval_base and hasattr(o, xname):
                    values = getattr(o, xname).values
                    xval_base = [values[base_value_idx] if isinstance(values, np.ndarray) else values]

        return yval_base, xval_base


class AllPlotData:
    """
    Store all individual PlotData objects

    Initialization parameters determine plot settings and must be specified as
    keyword arguments.  Plot data is set in a separate call using the set()
    method.

    Parameters (all optional keyword arguments):
    * replace_offset_text (bool): If the offset axes text should be put in the axes labels
    * allow_title_name (bool): If the variable name is allowed to appear in the title
    * allow_title_runid (bool): If the runid is allowed to appear in the title
    * allow_title_time (bool): If the time is allowed to appear in the title
    * allow_title_rho (bool): If the rho value is allowed to appear in the title
    * allow_title_factor (bool): If the scan factor is allowed to appear in the title
    * invert_y_axis (bool): If the y-axis should be inverted
    * invert_x_axis (bool): If the x-axis should be inverted
    * nomralize_y_axis (bool): If the y-axis should be normalized
    * normalize_x_axis (bool): If the x-axis should be normalized
    * savename_append (str): Name to append to the saved file when autosaving
    * summed_modes (bool): If the modes were summed (generally applies to diffusivity)
    * title_override (str): Overrides auto generated title if non-empty
    * ylabel_override (str): Overrides auto generated ylabel if non-empty
    * xlabel_override (str): Overrides auto generated xlabel if non-empty
    * yaxis_padding (float): The amount to pad the yaxis limits
    * xaxis_padding (float): The amount to pad the xaxis limits
    * xaxis_trim_padding (float): The amount to pad the trimmed xaxis limits when using rho values
    * ymin (float | None): The minimum y-value to use
    * ymax (float | None): The maximum y-value to use
    * xmin (float | None): The minimum x-value to use
    * xmax (float | None): The maximum x-value to use
    * ymin_cutoff (float | None): The minimum cutoff y-value to use
    * ymax_cutoff (float | None): The maximum cutoff y-value to use
    * xmin_cutoff (float | None): The minimum cutoff x-value to use
    * xmax_cutoff (float | None): The maximum cutoff x-value to use
    """

    def __init__(self, **kwargs):
        self.replace_offset_text: bool = True
        self.allow_title_name: bool = True
        self.allow_title_runid: bool = True
        self.allow_title_time: bool = True
        self.allow_title_rho: bool = True
        self.allow_title_factor: bool = True
        self.invert_y_axis: bool = False
        self.invert_x_axis: bool = False
        self.nomralize_y_axis: bool = False
        self.nomralize_x_axis: bool = False
        self.savename_append: str = ''
        self.summed_modes: bool = False
        self.title_override: str = ''
        self.ylabel_override: str = ''
        self.xlabel_override: str = ''
        self.yaxis_padding: float = 0.01
        self.xaxis_padding: float = 0.005
        self.xaxis_trim_padding: float = 0.03
        self.ymin: float | None = None
        self.ymax: float | None = None
        self.xmin: float | None = None
        self.xmax: float | None = None
        self.ymin_cutoff: float | None = None
        self.ymax_cutoff: float | None = None
        self.xmin_cutoff: float | None = None
        self.xmax_cutoff: float | None = None

        self._set_kwargs(kwargs)

        # Set these after kwargs are set
        self.data = None
        self.legend_attrs = None
        self.show_legend = None
        self.contains_timeplot = False

    def set(self, *args, **kwargs):
        """
        Set data for the plot

        Parameters:
        * args (tuple[PlotData]): Data to be plotted
        """

        self._set_kwargs(kwargs)
        self.data: list[PlotData] = [a for a in args if isinstance(a, PlotData)]

        if self.nomralize_y_axis:
            for d in self.data:
                if min(d.yvals) != max(d.yvals):
                    d.yval_base = (d.yval_base - min(d.yvals)) / (max(d.yvals) - min(d.yvals))
                    d.yvals = (d.yvals - min(d.yvals)) / (max(d.yvals) - min(d.yvals))
                else:
                    d.yval_base = 0
                    d.yvals[:] = 0

        if self.nomralize_x_axis:
            for d in self.data:
                if min(d.xvals) != max(d.xvals):
                    d.xval_base = (d.xval_base - min(d.xvals)) / (max(d.xvals) - min(d.xvals))
                    d.xvals = (d.xvals - min(d.xvals)) / (max(d.xvals) - min(d.xvals))
                else:
                    d.xval_base = 0
                    d.xvals[:] = 0

        if self.summed_modes:  # TODO: replace with controls check
            for d in self.data:
                if '\chi' in d.ysymbol:
                    stripped_label = d.ysymbol.strip('$')
                    d.ysymbol = f'$_{{^\sum}}{stripped_label}$'

        self._init_legend_dict()
        self._update_rho_str()

    @staticmethod
    def _format_offset_text(offset_text):
        """
        Format the offset text for each axis

        Offset text is generated by MatPlotLib and is usually just the
        exponent '\\times 10^{n}' that can appear for each axis.  This offset
        text can also contain an additive term however, which happens when
        the values being plotted change by a very small amount around a value
        that's not nearly 0.  For example, if values ranged from 2 + 1e-6 to
        2 + 2e-6, then an additive term of +2 would appear in the offset
        text.

        Parameters:
        * offset_text (str): The offset text of the axis

        Returns:
        * (str): The formatted offset text
        """

        if not offset_text:
            return offset_text

        if '+' in offset_text:
            number_str = offset_text.split('+')[1].split('}')[0]
            number = f'{float(number_str):.12g}'
            offset_text = offset_text.replace(number_str, number)

        return f' {offset_text}'

    def _init_legend_dict(self):
        """Store whether each attribute should be shown in the legend"""
        self.legend_attrs: dict[str, bool] = {
            'show_ysymbol': self.get_legend_include('ysymbol'),
            'show_xsymbol': self.get_legend_include('xsymbol'),
            'show_runid': self.get_legend_include('runid'),
            'show_runname': self.get_legend_include('runname'),
            'show_time': self.get_legend_include('time'),
            'show_rho': self.get_legend_include('rho'),
            'show_factor': self.get_legend_include('factor'),
            'show_factor_symbol': self.get_legend_include('factor_symbol'),
            'show_is_cdf': self.get_legend_include('is_cdf'),
            'show_is_csv': self.get_legend_include('is_csv'),
            'show_calc_source': self.get_legend_include('source'),
            'show_override': self.get_legend_include('legend'),
            'show_zval': self.get_legend_include('zval'),
        }

        self.show_legend: bool = np.array([v for v in self.legend_attrs.values()]).any()
        self.contains_timeplot: bool = np.array([d.timeplot for d in self.data]).any()

    def _update_rho_str(self):
        """
        Update rho strings so that trailing zeros are removed while the same
        number of decimal points are kept for each rho value.

        Example:

            rho1, rho2 = 0.900, 0.720

            >>> rho1, rho2 = 0.90, 0.72
        """

        # Get the max number of decimal points used for all rho
        rho_lengths = [0]  # Fill with 0 so that the list isn't empty when calling max()
        for d in self.data:
            if d.rho:
                split_decimal = f'{float(d.rho):.12g}'.split('.')
                if len(split_decimal) > 1:
                    rho_lengths.append(len(split_decimal[1]))  # num decimal points with trailing 0's removed

        rho_length = max(rho_lengths)

        # Update rho strings by removing trailing 0's while keeping the same amount of decimals on each rho
        if rho_length:
            for i, d in enumerate(self.data):
                if d.rho:
                    d.rho = f'{float(d.rho):.{rho_length}f}'

    def _set_kwargs(self, kwargs):
        """Set member values using keyword arguments"""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
            else:
                _log.error(f'\n\t"{key}" is not a valid parameter for AllPlotData')

    @staticmethod
    def _get_units_str(units):
        """Returns (str) The formatted units of the variable"""
        # Note: The units parameter may already contain '$' symbols, which
        # breaks the \left and \right commands we are using, so those symbols
        # are removed and placed back in at the ends of the return string
        return "".join([r"$", fr'\left(\mathrm{{{units}}}\right)'.replace('$', ''), r"$"]) if units else ''

    def get_legend_label(self, plotdata):
        """
        Get the individual label for the plot legend

        Since the rules for constructing legend labels depend on the loaded
        data as a whole, a PlotData object needing a legend label is passed
        into here first, before having it's own label methods called.

        If the legend override is set, then that value is used for the legend
        label.  Otherwise, attributes such as the variable symbol, runid,
        time, rho value, scan factor, calculation source, or data source may
        each be automatically added to the legend.  In general, attributes
        are only added to the legend if multiple plotted variables have
        different values for a given attribute.

        Parameters:
        * plotdata (PlotData): Object containing plot data

        Returns:
        * (str): The legend label for the variable
        """

        if plotdata.legend:
            return plotdata.legend

        legend_items = []
        if self.legend_attrs['show_ysymbol'] and not self.legend_attrs['show_xsymbol']:
            legend_items.append(plotdata.get_ysymbol_label_str())
        if self.legend_attrs['show_xsymbol']:
            legend_items.append(plotdata.get_xsymbol_label_str())
        if self.legend_attrs['show_runid'] or self.legend_attrs['show_runname']:
            legend_items.append(plotdata.get_run_label_str())
        if self.legend_attrs['show_time']:
            legend_items.append(plotdata.get_time_label_str())
        if self.legend_attrs['show_rho'] and plotdata.rho is not None:
            legend_items.append(plotdata.get_rho_label_str())
        if self.legend_attrs['show_factor'] or self.legend_attrs['show_factor_symbol']:
            legend_items.append(plotdata.get_factor_label_str())
        if self.legend_attrs['show_calc_source']:
            legend_items.append(plotdata.get_calc_source_str())
        if self.contains_timeplot and self.legend_attrs['show_zval']:
            legend_items.append(plotdata.get_zval_str())
        if self.legend_attrs['show_is_cdf'] and self.legend_attrs['show_is_csv'] and not legend_items:
            legend_items.append(plotdata.get_data_source_str())  # only show when legend is empty

        return ' '.join(legend_items)

    def get_legend_include(self, attr_name):
        """
        Determine if a legend attribute should be included in the legend

        The rule for adding an attribute to the legend is if multiple plotted
        variables have different values for a checked attribute.  For example, if
        var A and var B both have different runid's, then their runid's are added
        to the legend.  If there is only one variable to plot, then no attributes
        will be added to the legend.

        Parameters:
        * attr_name (str): The name of a LegendAttributes member

        Returns:
        * (bool) True if the attribute should be added to the legend
        """

        attrs = set()
        for d in self.data:
            attrs.add(getattr(d, attr_name))

        return len(attrs) > 1

    def get_plot_limits(self):
        """
        Get the limits of the plot, adjusted by padding parameters set in plot settings

        The axes limits are adjusted by the percentage given for xpad and ypad
        in the plot settings object, in each direction for either axis.  For
        example, if ypad = 1, then the limits of the yaxis are both increased
        and decreased by 1%.  Note that MatPlotLib uses default padding of
        something like 5% on each axis, so setting padding values smaller
        than this value will produce tighter plots than what would be created
        if the padding wasn't adjusted.

        Returns:
        * xlims (tuple[float]): The x-axis limits of the plot
        * ylims (tuple[float]): The y-axis limits of the plot
        """

        def get_lims(minval, maxval, padding, invert_axis):
            """Get the axis limits after applying padding, checking values, and checking axis inversion"""
            if minval < maxval:
                offset = (maxval - minval) * padding
                minval, maxval = minval - offset, maxval + offset
            else:
                minval -= 1  # default values
                maxval += 1
            return (minval, maxval) if not invert_axis else (maxval, minval)

        # all_xvals = np.hstack([d.xvals for d in self.data[1:]])
        # all_yvals = np.hstack([d.yvals for d in self.data[1:]])
        all_xvals = np.hstack([d.xvals for d in self.data])
        all_yvals = np.hstack([d.yvals for d in self.data])
        xmin, xmax = all_xvals[~np.isnan(all_xvals)].min(), all_xvals[~np.isnan(all_xvals)].max()
        ymin, ymax = all_yvals[~np.isnan(all_yvals)].min(), all_yvals[~np.isnan(all_yvals)].max()

        # Set cutoff values for each axis
        if self.xmin_cutoff is not None:
            xmin = max(xmin, self.xmin)
        if self.xmax_cutoff is not None:
            xmax = min(xmax, self.xmax)
        if self.ymin_cutoff is not None:
            ymin = max(ymin, self.ymin)
        if self.ymax_cutoff is not None:
            ymax = min(ymax, self.ymax)

        # Set strict axes boundaries
        if self.xmin is not None:
            xmin = self.xmin
        if self.xmax is not None:
            xmax = self.xmax
        if self.ymin is not None:
            ymin = self.ymin
        if self.ymax is not None:
            ymax = self.ymax

        # using_rho = (np.array([d.rho for d in self.data]) != None).any()  # '!= None' syntax is needed with numpy

        # if using_rho:
        #     xvals_trim = all_xvals[np.absolute(all_yvals) / max(abs(ymin), abs(ymax)) > 1e-3]  # Trim the x-limits of zeros
        #     xmin_trim, xmax_trim = xvals_trim.min(), xvals_trim.max()
        #     xoffset_trim = (xmax_trim - xmin_trim) * plot_settings.xaxis_trim_padding
        #     xmin = max(xmin, xmin_trim - xoffset_trim)  # Keep trimmed xmin >= actual xmin
        #     xmax = min(xmax, xmax_trim + xoffset_trim)  # Keep trimmed xmax <= actual xmax

        xlims = get_lims(xmin, xmax, self.xaxis_padding, self.invert_x_axis)
        ylims = get_lims(ymin, ymax, self.yaxis_padding, self.invert_y_axis)

        return xlims, ylims

    def get_plot_title(self):
        """
        Get the title for the plot

        If the title override is set, then the title override value is used
        for the title of the plot.

        If there is no title override, then a title is generated from the
        intersection of all words in the names of the y-variables being
        plotted.

        Title details are added when all variables share the same value of the
        corresponding attribute.  Possible details are: runid, time, scan
        factor, rho value.

        Returns:
        * (str): The title for the plot
        """

        if self.title_override:
            base_title = self.title_override
        elif self.allow_title_name:
            base_title = self._generate_unique_title()
        else:
            base_title = ''

        base_title = base_title.strip()
        title_details = self._get_title_details()

        if base_title and title_details:
            title_details = f' ({title_details})'

        return f'{base_title}{title_details}'

    def _generate_unique_title(self):
        """
        Generate a title by taking the intersection of all words that appear
        in the name of each y-variable being plotted.

        Example 1:
            name1 = 'Thermal Ion Density'
            name2 = 'Deuterium Ion Density'

            >>> The generated title would be 'Ion Density', since both of
                these words are in each name.

        Example 2:
            name1 = 'Thermal Ion Density'
            name2 = 'Deuterium Ion Density'
            name3 = 'Electron Density'

            >>> The generated title would be 'Density', since this is the only
                word that is in each name.

        Note that the title will be blank if the intersection of all words is
        empty.

        Returns:
        * (str): The unique title for the plot
        """

        unique_ynames = set([data.yvarname for data in self.data])
        first_name_words = self.data[0].yvarname.split()
        title_words = []

        # Form list of title words for words that appear in the first y-variable name
        for word in first_name_words:
            append_word = True
            for name in unique_ynames:
                if word not in name:
                    append_word = False
                    break
            if append_word:
                title_words.append(word)

        return ' '.join(title_words)

    def _get_title_details(self):
        """
        Get the title details

        Details are added to the title if the corresponding title details
        switch is enabled and all variables share the same value for that
        attribute. Possible title details include the runid, time, and rho
        value for each plotted variable.  For example, if all plotted
        variables share the same runid, then the runid is added to the
        title.

        Returns:
        * (str): The details to add to the title
        """

        title_details_list = []
        allow_runid = self.allow_title_runid
        allow_time = self.allow_title_time
        allow_rho = self.allow_title_rho
        allow_factor = self.allow_title_factor

        if allow_runid or allow_time or allow_rho:
            var = self.data[0]  # use first variable values for title details (same for all variables)

            if allow_runid and not self.legend_attrs['show_runid'] and not self.legend_attrs['show_runname']:
                # all lines have same runid or runname
                title_details_list.append(var.get_run_label_str())
            if allow_time and not self.legend_attrs['show_time'] and not self.contains_timeplot:
                # all lines have same time
                title_details_list.append(var.get_time_label_str())
            if allow_rho and not self.legend_attrs['show_rho'] and var.rho is not None:
                # all lines have same rho, and rho is not None
                title_details_list.append(var.get_rho_label_str())
            if (allow_factor and not self.legend_attrs['show_factor']
                    and not self.legend_attrs['show_factor_symbol'] and var.factor is not None):
                title_details_list.append(var.get_factor_label_str())

        return f'{", ".join(title_details_list)}' if title_details_list else ''

    def get_plot_ylabel(self, offset_text):
        """
        Get the yaxis label for the plot

        If the ylabel override is set, then that is used for the ylabel of the
        plot.  Otherwise, the unique units of each y-variable are added to the
        ylabel (the same units aren't repeated).  Additionally, if the y-variable
        symbols do not appear in the legend, then these unique symbols are also
        added to the ylabel.

        Parameters:
        * offset_text (str): The offset text from the y-axis of the plot

        Returns:
        * (str): The ylabel for the plot
        """

        offset_text = self._format_offset_text(offset_text)

        if self.ylabel_override:
            return f'{self.ylabel_override}{offset_text}'

        ylabels = []  # Not using a set to preserve order
        for d in self.data:
            units_str = self._get_units_str(d.yunits)
            if not self.legend_attrs['show_ysymbol'] and not self.legend_attrs['show_xsymbol']:
                # ysymbol not in legend
                ystr = fr'{d.ysymbol} {units_str}'
                if ystr not in ylabels:
                    ylabels.append(ystr)
            elif units_str not in ylabels:  # ysymbol is in the legend (showing xsymbol also shows ysymbol)
                ylabels.append(units_str)

        joined_labels = r'$\!$,  '.join(ylabels)  # small negative space before each comma

        if self.nomralize_y_axis:
            joined_labels = f'{joined_labels} (normalized)'

        return f'{joined_labels}{offset_text}'

    def get_plot_xlabel(self, offset_text):
        """
        Get the xaxis label for the plot

        If the xlabel override is set, then that is used for the xlabel of the
        plot.  Otherwise, the unique symbols and units of each x-variable are
        added to the ylabel (the same units aren't repeated).

        Parameters:
        * offset_text (str): The offset text from the x-axis of the plot

        Returns:
        * (str): The xlabel for the plot
        """

        offset_text = self._format_offset_text(offset_text)

        if self.xlabel_override:
            return f'{self.xlabel_override}{offset_text}'

        xlabels = []  # Not using a set to preserve order
        for d in self.data:
            xstr = f'{d.xsymbol} {self._get_units_str(d.xunits)}'
            if xstr not in xlabels:
                xlabels.append(xstr)

        joined_labels = r'$\!$,  '.join(xlabels)  # small negative space before each comma

        if self.nomralize_x_axis:
            joined_labels = f'{joined_labels} (normalized)'

        return f'{joined_labels}{offset_text}'

    def save_to_csv(self, file_name=''):
        """
        Save plotted data to a CSV

        Data is saved in the order it is generated, so the first CSV column
        will be the first variable defined in AllPlotData, etc.  Filenames
        are chosen as sequentially increasing integers.

        Raises:
        * NameError: If a file name can not be chosen
        * FileNotFoundError: If the file cannot be found after saving it
        """

        show_save_message = False

        if not file_name:  # Automatically generate the save name using a unique number
            show_save_message = True
            save_name_digits = 4
            save_dir = f'{utils.get_plotting_singles_path()}\\misc'
            utils.create_directory(save_dir)
            saved_files = utils.get_files_in_dir(save_dir, '*.csv')
            for save_number in range(1, 10**save_name_digits):
                file_name = f'{save_dir}\\{save_number:0>{save_name_digits}d}'
                if f'{file_name}.csv' not in saved_files:
                    break

            if not file_name:
                raise NameError('The filename for the CSV could not be set\n'
                                '\tMake sure Python has file reading permissions,'
                                ' and try deleting old CSVs from the CSV folder\n')

        file_name = f'{file_name}.csv'

        max_var_length = max([len(d.xvals) for d in self.data])
        num_vars = 2 * len(self.data)

        output = np.full((max_var_length, num_vars), np.nan, dtype=float)
        for i, d in enumerate(self.data):
            output[:len(d.xvals), 2 * i] = d.xvals
            output[:len(d.yvals), 2 * i + 1] = d.yvals

        prec, col_pad = 4, 7
        col_len = prec + col_pad
        fmt_str = f'%{col_len}.{prec}e'
        header = ',  '.join([f'{d.xname:>{col_len - 2}},  {d.yname:>{col_len - 2}}' for d in self.data])

        np.savetxt(file_name, output, header=header, fmt=fmt_str, delimiter=',')

        if not utils.check_exists(file_name):
            raise FileNotFoundError('Failed to save plot data to a CSV in the CSV folder\n'
                                    '\tMake sure Python has file writing permissions')

        if show_save_message:
            print(f'Plot Data Saved:\n\t{file_name}\n')  # Intentionally not using logging


def main(all_data, savefig=False, savedata=False):
    """
    Create a plot using data loaded from CDF files

    This method advances the plot cycler twice for each variable in
    AllPlotData, by plotting twice for each variable.  The first plot is a
    line of the normal data for the variable, and the second plot is a single
    point of the base value for the previously plotted line.  When a variable
    contains no base values, as is the case when not plotting a specific
    point of rho, then empty lists are plotted; this allows us to advance the
    cycler without adding anything to the plot, as no methods exist for us to
    directly increment the cycler.

    Parameters:
    * all_data (AllPlotData): Object containing all PlotData objects
    * savefig (bool): Automatically save the plot without showing it if True
    * savedata (bool): Automatically save the data as a CSV
    """

    def on_press(event):
        if event.key == 'x':  # flip x-axis limits
            plt.xlim(plt.xlim()[::-1])
            fig.canvas.draw()

        if event.key == 'y':  # flip y-axis limits
            plt.ylim(plt.ylim()[::-1])
            fig.canvas.draw()

        if event.key == "ctrl+c":  # copy figure to clipboard
            save_format = plt.rcParams['savefig.format']
            plt.rcParams.update({'savefig.format': 'png'})
            with io.BytesIO() as buffer:
                fig.savefig(buffer)
                QApplication.clipboard().setImage(QImage.fromData(buffer.getvalue()))
                plt.rcParams.update({'savefig.format': save_format})

        if event.key == 'alt+s':  # save plot lines to csv
            all_data.save_to_csv()

    fig, ax = plt.gcf(), plt.gca()
    fig.canvas.mpl_connect('key_press_event', on_press)

    for d in all_data.data:
        ax.plot(d.xvals, d.yvals, label=all_data.get_legend_label(d))
        ax.plot(d.xval_base, d.yval_base, zorder=3)  # Advance the cycler when base values are empty lists

    xlims, ylims = all_data.get_plot_limits()
    ax.set(xlim=xlims, ylim=ylims)  # lims need to be set before getting offsetText

    offset_text_x = offset_text_y = ''
    if all_data.replace_offset_text:
        fig.canvas.draw()  # needed to populate the offsetText string
        ax.xaxis.offsetText.set_visible(False)
        ax.yaxis.offsetText.set_visible(False)
        offset_text_x = ax.xaxis.offsetText.get_text()
        offset_text_y = ax.yaxis.offsetText.get_text()

    ax.set(
        title=all_data.get_plot_title(),
        xlabel=all_data.get_plot_xlabel(offset_text_x),
        ylabel=all_data.get_plot_ylabel(offset_text_y),
    )

    if all_data.show_legend:
        ax.legend().set_draggable(state=True)

    if savefig or savedata:
        ynames_list = list(set([d.yname for d in all_data.data]))
        ynames_list.sort()
        ynames = ''.join(ynames_list)

        # These flags are based on the first variable being plotted
        if all_data.data[0].options.use_gnezero:
            ynames = f'{ynames}_gne0'
        if all_data.data[0].options.use_gtezero:
            ynames = f'{ynames}_gte0'
        if all_data.data[0].options.use_gneabs:
            ynames = f'{ynames}_gneabs'
        if all_data.savename_append:
            ynames = f'{ynames}_{all_data.savename_append}'
        if all_data.data[0].timeplot:
            ynames = f'{ynames}_time'

        savedir_base = f'{utils.get_plotting_singles_path()}\\{all_data.data[0].options.runid}'
        utils.create_directory(savedir_base)

    if savedata:
        savedir = f'{savedir_base}\\data'
        utils.create_directory(savedir)
        all_data.save_to_csv(f'{savedir}\\{ynames}')

    if savefig:
        savedir = f'{savedir_base}\\figures'
        utils.create_directory(savedir)
        fig.savefig(f'{savedir}\\{ynames}')
        fig.clear()
    else:
        plt.show()


if __name__ == '__main__':
    """Run this module directly to plot variable data stored in CDF or CSV files"""

    utils.init_logging()

    # Initialize visual styles for the plot
    PlotStyles(
        axes=StyleType.Axes.WHITE,
        lines=StyleType.Lines.RHO_MMM,
        layout=StyleType.Layout.SINGLE1B,
    )

    plt.rcParams.update({
        'savefig.format': 'pdf',  # Common save formats: png, pdf, eps
    })

    # Define settings for the plot
    all_data = AllPlotData(
        replace_offset_text=False,
        allow_title_runid=True,
        allow_title_time=True,
        allow_title_factor=True,
        allow_title_rho=True,
        invert_y_axis=False,
        invert_x_axis=False,
        nomralize_y_axis=False,
        nomralize_x_axis=False,
        title_override=' ',
        ylabel_override='',
        xlabel_override='',
    )

    # Define data for the plot (Examples shown below)
    all_data.set(
        # CDF: Same y-variable, different x-variables
        PlotDataCdf(runid='138536A01', yname='te', xname='rmina', zval=0.50),
        PlotDataCdf(runid='138536A01', yname='te', xname='rho', zval=0.50),
        # CDF: Different y-variable units
        # PlotDataCdf(runid='138536A01', yname='te', xname='rho', zval=0.50),
        # PlotDataCdf(runid='138536A01', yname='ti', xname='rho', zval=0.50),
        # PlotDataCdf(runid='138536A01', yname='btor', xname='rho', zval=0.50),
        # CDF: Different runid, y-variables, and zvals
        # PlotDataCdf(runid='120982A09', yname='ne', xname='rho', zval=0.60),
        # PlotDataCdf(runid='120968A02', yname='ni', xname='rho', zval=0.50),
        # PlotDataCdf(runid='129041A10', yname='nd', xname='rho', zval=0.40),
        # CDF: Compare as a function of time
        # PlotDataCdf(runid='138536A01', yname='te', xname='time', zval=0.40, timeplot=True),
        # PlotDataCdf(runid='138536A01', yname='te', xname='time', zval=0.50, timeplot=True),
        # PlotDataCdf(runid='138536A01', yname='te', xname='time', zval=0.60, timeplot=True),
        # CDF: Compare TRANSP and MMM calculations (must be defined in calculations.py)
        # PlotDataCdf(runid='141552A01', yname='loge', xname='rho', zval=0.629, source='cdf'),
        # PlotDataCdf(runid='141552A01', yname='loge', xname='rho', zval=0.629),
        # CDF and CSV: Compare same variable from different data sources
        # PlotDataCdf(runid='138536A01', yname='ne', xname='rho', zval=0.629),
        # PlotDataCsv(runid='138536A01', yname='ne', xname='rho', scan_num=2),
        # CSV: Different scanned variables with same scan factor
        # PlotDataCsv(runid='138536A01', yname='ne', xname='rho', scan_num=1, scan_factor=2.5),
        # PlotDataCsv(runid='138536A01', yname='ne', xname='rho', scan_num=2, scan_factor=2.5),
        # PlotDataCsv(runid='138536A01', yname='ne', xname='rho', scan_num=5, scan_factor=2.5),
        # CSV: Comparing output results
        # PlotDataCsv(runid='138536A01', yname='xteETGM', xname='rho', scan_num=17, legend='exbs = 0'),
        # PlotDataCsv(runid='138536A01', yname='xteETGM', xname='rho', scan_num=54, legend='exbs = 1'),
        # # CSV: Growth rate vs \eta_e
        # PlotDataCsv(runid='138536A01', yname='gmaETGM', xname='etae', scan_num=35, rho_value=0.10),
        # CSV: Growth rate as a function of different scanned variables
        # PlotDataCsv(runid='138536A01', yname='gmaETGM', xname='var_to_scan', scan_num=15, rho_value=0.39, runname=r'OLD'),
        # PlotDataCsv(runid='138536A01', yname='gmaETGM', xname='var_to_scan', scan_num=55, rho_value=0.39, runname=r'NEW'),
    )

    all_data.set(
        # PlotDataCsv(runid='120968A02', yname='gmanormMTM', xname='rho', scan_num=13),
        PlotDataCsv(runid='129016A04', yname='xteMTM', xname='rho', scan_num=9),
        PlotDataCsv(runid='129016A04', yname='xteMTM', xname='rho', scan_num=8),
        # PlotDataCdf(runid='129016A04', yname='nuste', xname='rho', zval=0.31),
        ymax=4,ymin=0,xmin=0.2,xmax=0.8,
    )

    main(all_data, savefig=False, savedata=False)
