#!/usr/bin/python3

"""Handles the entire flow of data both to and from MMM

The controller is meant to be ran directly to execute one of three different
MMM runs.  The different run types the controller supports are:
* Basic Run: MMM is ran once using data obtained from TRANSP.  Various profile
  plot PDFs are created, and all used data is saved to CSVs.  This run is
  fundamental to storing all non-scanned variable data, so a basic run is
  also executed at the start of both variable and control scans.
* Variable Scan: Values of a specified variable are adjusted using a range of
  scan factors, which are multiplicative factors.  MMM is ran once for each
  factor in the scan range.  Valid variables to scan must be members of the
  InputVariables class.
* Control Scan: Values of a specified control are adjusted using a range of
  scan factors, in similar fashion to a variable scan.  Valid controls to
  scan must be members of the InputControls class.

When conducting either a variable or control scan, values of all input,
additional, and output variables are saved to CSV for each factor in the scan
range.  Factor files contain variable data as functions of rmin (or rho),
where each file corresponds to a different scan factor value (noted by the
filename). After the scan is completed, this saved data is then reshaped and
saved again into new rho files, which contain values of each variable type at
a specified point of rho.  Rho files contain variable data as function of the
scanned variable at each point of rho, where each file corresponds to a
different rho value (noted by the filename).

A new scan number is created each time a new run is executed.  This means that
new data generated by MMM will never overwrite previously generated data. The
trade-off of this is that many scan folders can be created over time, and it
is up to the user to maintain the folders as necessary.

In terms of plot generation, the controller only produces plots of base profiles
(unaltered by scan factors).  Plots from data stored in scan factor files or
rho files should be generated by directly running the various modules
provided in the plotting directory.

Example Usage:
* See commands listed at the bottom of this file
"""

# Standard Packages
from copy import deepcopy

# 3rd Party Packages
import numpy as np

# Local Packages
import settings
import modules.adjustments as adjustments
import modules.controls as controls
import modules.datahelper as datahelper
import modules.mmm as mmm
import modules.options as options
import modules.reshaper as reshaper
import modules.utils as utils
import plotting.modules.profiles as profiles
from modules.enums import ShotType, ScanType, ProfileType


def _execute_basic_run(mmm_vars, input_controls, opts):
    '''
    Executes a single MMM run, without varying any input parameters

    Creates an input file for the MMM driver using mmm_vars.  The MMM driver
    is then ran, which produces an output file.  This output file is parsed
    and a CSV of both the input and output data are stored, and an output
    profile PDF is created.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write MMM input file
    * input_controls (InputControls): Specifies input control values in the MMM input file
    * opts (Options): A reference to modules.options.instance
    '''

    output_vars = mmm.run_wrapper(mmm_vars, input_controls)
    output_vars.save_all_vars(opts.runid, opts.scan_num)
    profiles.plot_profiles(ProfileType.OUTPUT, output_vars)


def _execute_variable_scan(mmm_vars, input_controls, opts):
    '''
    Executes an input variable scan, where the values of an input variable are
    varied over a specified range and are then sent to the MMM driver for
    each value of the range

    Create a copy of mmm_vars as modified_vars to keep variables that are
    modified over the course of the scan separate from base MMM input
    variables.  For each factor of the scan_range, we modify the value of the
    specified var_to_scan, and then adjust any dependent variables. The MMM
    driver is ran each time var_to_scan is adjusted, and all input and output
    variable data is saved to a subfolder named after var_to_scan.
    Afterwards, the saved CSV data is reshaped into data dependent on the
    scanned parameter, and is saved to another set of CSV within a new
    subfolder labeled rho.

    Parameter scan PDFs are not produced here, and the output data is intended
    to be plotted by a separate process after the scan is complete.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write the MMM input file
    * input_controls (InputControls): Specifies input control values in the MMM input file
    * opts (Options): A reference to modules.options.instance
    '''

    for i, scan_factor in enumerate(opts.scan_range):
        print(f'Executing variable scan {i + 1} of {len(opts.scan_range)} for {opts.var_to_scan}')
        adjusted_vars = adjustments.adjust_scanned_variable(mmm_vars, opts.var_to_scan, scan_factor)
        save_args = (opts.runid, opts.scan_num, opts.var_to_scan, scan_factor)
        adjusted_vars.save_all_vars(opts.time_idx, *save_args)
        output_vars = mmm.run_wrapper(adjusted_vars, input_controls)
        output_vars.save_all_vars(*save_args)

    reshaper.create_rho_files()  # Creates CSVs in the rho folder

    print('\nVariable scan complete!')


def _execute_control_scan(mmm_vars, input_controls, opts):
    '''
    Executes an input control scan, where the values of an input control are
    varied over a specified range and are then sent to the MMM driver for
    each value of the range

    Parameter scan PDFs are not produced here, and the output data is intended
    to be plotted by a separate process after the scan is complete.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write MMM input file
    * input_controls (InputControls): Specifies input control values in the MMM input file
    * opts (Options): A reference to modules.options.instance
    '''

    # Create a reference to control being scanned in InputControls. Modifying
    # scanned_control values will modify its corresponding values in
    # adjusted_controls

    adjusted_controls = deepcopy(input_controls)
    scanned_control = getattr(adjusted_controls, opts.var_to_scan)
    base_control = getattr(input_controls, opts.var_to_scan)

    for i, scan_factor in enumerate(opts.scan_range):
        print(f'Executing control scan {i + 1} of {len(opts.scan_range)} for {opts.var_to_scan}')
        scanned_control.values = scan_factor * base_control.values
        save_args = (opts.runid, opts.scan_num, opts.var_to_scan, scan_factor)
        mmm_vars.save_all_vars(opts.time_idx, *save_args)
        adjusted_controls.save_to_csv(*save_args)
        output_vars = mmm.run_wrapper(mmm_vars, adjusted_controls)
        output_vars.save_all_vars(*save_args)

    reshaper.create_rho_files()  # Creates CSVs in the rho folder

    print('\nInput control scan complete!')


def main(scanned_vars, input_controls, opts):
    '''
    Runs the MMM controller

    Needed output folders are created and a unique scan number is chosen for
    storing output data. All input variable objects are initialized and
    corresponding plot PDFs are created.  The MMM driver is then ran once,
    and then an optional variable scan can be ran afterwards.

    Parameters:
    * scanned_vars (Dict): Dictionary of variables being scanned
        - keys (str or None): The variable being scanned
        - values (np.ndarray or None): The range of factors to scan over
    * input_controls (InputControls): Specifies input control values in the MMM input file
    * opts (Options): A reference to modules.options.instance
    '''

    # TODO: Add validation for all items in scanned_vars
    for var_to_scan, scan_range in scanned_vars.items():
        print(f'Running MMM Controller...\n')

        opts.scan_num = utils.get_scan_num(opts.runid)
        opts.set(var_to_scan=var_to_scan, scan_range=scan_range)

        utils.clear_temp_folder()
        utils.init_output_dirs(opts.runid, opts.scan_num, opts.var_to_scan)

        mmm_vars, cdf_vars, __ = datahelper.initialize_variables()

        opts.save()  # Needs to be saved after variable initialization
        input_controls.save_to_csv(opts.runid, opts.scan_num)
        mmm_vars.save_all_vars(opts.time_idx, opts.runid, opts.scan_num)

        profiles.plot_profiles(ProfileType.INPUT, mmm_vars)
        profiles.plot_profiles(ProfileType.ADDITIONAL, mmm_vars)
        profiles.plot_profiles(ProfileType.COMPARED, mmm_vars, cdf_vars)

        # Basic runs create output profile plots and save output profile CSVs
        _execute_basic_run(mmm_vars, input_controls, opts)

        if opts.scan_type == ScanType.VARIABLE:
            _execute_variable_scan(mmm_vars, input_controls, opts)
        elif opts.scan_type == ScanType.CONTROL:
            _execute_control_scan(mmm_vars, input_controls, opts)


# Run this file directly to plot variable profiles and run the MMM driver
if __name__ == '__main__':
    scanned_vars = {}

    '''
    TRANSP Data:
    * Uncomment the line you wish to use
    '''
    # runid, shot_type, input_time = '120968A02', ShotType.NSTX, 0.5
    # runid, shot_type, input_time = '120982A09', ShotType.NSTX, 0.5
    # runid, shot_type, input_time = '129041A10', ShotType.NSTX, 0.5
    # runid, shot_type, input_time = '138536A01', ShotType.NSTX, 0.630
    # runid, shot_type, input_time = '132017T01', ShotType.DIII_D, 2.1
    # runid, shot_type, input_time = '141552A01', ShotType.DIII_D, 2.1
    runid, shot_type, input_time = 'TEST', ShotType.NSTX, 0.5

    '''
    Scanned Variables:
    * Uncomment the lines you wish to include in scanned_vars
    * Using None as the scanned variable will skip the variable scan
    '''
    # scanned_vars[None] = None
    scanned_vars['betae'] = np.arange(start=0.5, stop=5 + 1e-6, step=0.5)

    # scanned_vars['betae'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['btor'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['etae'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['etgm_kyrhoe'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['etgm_kyrhos'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['gnh'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['gnz'] = np.arange(start=0.05, stop=9 + 1e-6, step=0.05)
    # scanned_vars['gte'] = np.arange(start=0.025, stop=6 + 1e-6, step=0.05)
    # scanned_vars['nuei'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['q'] = np.arange(start=0.6, stop=2.4 + 1e-6, step=0.015)
    # scanned_vars['shear'] = np.arange(start=-6.0, stop=6 + 1e-6, step=0.1)
    # scanned_vars['tau'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['zeff'] = np.arange(start=0.02, stop=4 + 1e-6, step=0.02)**2

    '''
    Options:
    * input_points is the number of points to use when making the MMM input file
    * Set input_points = None to match the number of points used in the CDF
    * Set uniform_rho = True to interpolate to a grid of evenly spaced rho values (takes longer)
    * apply_smoothing enables smoothing of all variables that have a smooth value set in the Variables class
    '''
    options.instance.set(
        runid=runid,
        shot_type=shot_type,
        input_time=input_time,
        input_points=101,
        uniform_rho=True,
        apply_smoothing=True,
    )

    '''
    Input Controls:
    * cmodel enables (disables) the corresponding model if set to 1 (0)
    '''
    input_controls = controls.InputControls(
        input_points=options.instance.input_points,
        cmodel_weiland=0,
        cmodel_dribm=0,
        cmodel_etg=0,
        cmodel_etgm=1,
        cmodel_mtm=0,
        etgm_kyrhoe=0.25,
        etgm_kyrhos=0.33,
        etgm_cl=1,  # etgm_cl=0 is collisionless, etgm_cl=1 is collisional
        etgm_exbs=1,
    )

    settings.AUTO_OPEN_PDFS = 0

    main(scanned_vars, input_controls, options.instance)
