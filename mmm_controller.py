#!/usr/bin/python3

"""Handles the entire flow of data both to and from MMM

The controller is meant to be ran directly to execute one of three different
MMM runs.  The different run types the controller supports are:
* Basic Run: MMM is ran once using data obtained from TRANSP.  Various profile
  plot PDFs are created, and all used data is saved to CSVs.  This run is
  fundamental to storing all non-scanned variable data, so a basic run is
  also executed at the start of both variable and control scans.
* Variable Scan: Values of a specified variable are adjusted using a range of
  scan factors, which are multiplicative factors.  MMM is ran once for each
  factor in the scan range.  Valid variables to scan must be members of the
  InputVariables class.
* Control Scan: Values of a specified control are adjusted using a range of
  scan factors, in similar fashion to a variable scan.  Valid controls to
  scan must be members of the InputControls class.

When conducting either a variable or control scan, values of all input,
additional, and output variables are saved to CSV for each factor in the scan
range.  Factor files contain variable data as functions of rmin (or rho),
where each file corresponds to a different scan factor value (noted by the
filename). After the scan is completed, this saved data is then reshaped and
saved again into new rho files, which contain values of each variable type at
a specified point of rho.  Rho files contain variable data as function of the
scanned variable at each point of rho, where each file corresponds to a
different rho value (noted by the filename).

A new scan number is created each time a new run is executed.  This means that
new data generated by MMM will never overwrite previously generated data. The
trade-off of this is that many scan folders can be created over time, and it
is up to the user to maintain the folders as necessary.

In terms of plot generation, the controller only produces plots of base profiles
(unaltered by scan factors).  Plots from data stored in scan factor files or
rho files should be generated by directly running the various modules
provided in the plotting directory.

Example Usage:
* See commands listed at the bottom of this file
"""

# 3rd Party Packages
import numpy as np

# Local Packages
import settings
import modules.controls
import modules.constants
import modules.options
import modules.calculations as calculations
import modules.adjustments as adjustments
import modules.datahelper as datahelper
import modules.mmm as mmm
import modules.reshaper as reshaper
import modules.utils as utils
import plotting.modules.profiles as profiles
from modules.enums import ShotType, ScanType, ProfileType


class CdfData():

    def __init__(self, runid, shot_type, input_time):
        self.runid = runid
        self.shot_type = shot_type
        self.input_time = input_time


def _execute_variable_scan(mmm_vars, controls):
    '''
    Executes an input variable scan, where the values of an input variable are
    varied over a specified range and are then sent to the MMM driver for
    each value of the range

    Create a copy of mmm_vars as modified_vars to keep variables that are
    modified over the course of the scan separate from base MMM input
    variables.  For each factor of the scan_range, we modify the value of the
    specified var_to_scan, and then adjust any dependent variables. The MMM
    driver is ran each time var_to_scan is adjusted, and all input and output
    variable data is saved to a subfolder named after var_to_scan.
    Afterwards, the saved CSV data is reshaped into data dependent on the
    scanned parameter, and is saved to another set of CSV within a new
    subfolder labeled rho.

    Parameter scan PDFs are not produced here, and the output data is intended
    to be plotted by a separate process after the scan is complete.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write the MMM input file
    * controls (InputControls): Specifies input control values in the MMM input file
    '''

    runid = mmm_vars.options.runid
    scan_num = mmm_vars.options.scan_num
    scan_range = mmm_vars.options.scan_range
    var_to_scan = mmm_vars.options.var_to_scan

    for i, scan_factor in enumerate(scan_range):
        print(f'{runid}.{scan_num} {var_to_scan} scan: {i + 1} / {len(scan_range)}')
        adjusted_vars = adjustments.adjust_scanned_variable(mmm_vars, scan_factor)
        adjusted_vars.save(scan_factor)
        output_vars = mmm.run_wrapper(adjusted_vars, controls)
        calculations.calculate_output_variables(mmm_vars, output_vars, controls)
        output_vars.save(scan_factor)


def _execute_control_scan(mmm_vars, controls):
    '''
    Executes an input control scan, where the values of an input control are
    varied over a specified range and are then sent to the MMM driver for
    each value of the range

    Parameter scan PDFs are not produced here, and the output data is intended
    to be plotted by a separate process after the scan is complete.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write MMM input file
    * controls (InputControls): Specifies input control values in the MMM input file
    '''

    # Create a reference to control being scanned in InputControls. Modifying
    # scanned_control values will modify its corresponding values in
    # adjusted_controls

    runid = mmm_vars.options.runid
    scan_num = mmm_vars.options.scan_num
    scan_range = mmm_vars.options.scan_range
    var_to_scan = mmm_vars.options.var_to_scan

    adjusted_controls = datahelper.deepcopy_data(controls)
    scanned_control = adjusted_controls.get_scanned_control()
    base_control = controls.get_scanned_control()

    for i, scan_factor in enumerate(scan_range):
        print(f'{runid}.{scan_num} {var_to_scan} scan: {i + 1} / {len(scan_range)}')
        scanned_control.values = scan_factor * base_control.values
        mmm_vars.save(scan_factor)
        adjusted_controls.save(scan_factor)
        output_vars = mmm.run_wrapper(mmm_vars, adjusted_controls)
        calculations.calculate_output_variables(mmm_vars, output_vars, controls)
        output_vars.save(scan_factor)


def _execute_time_scan(mmm_vars, controls):
    '''
    Executes an input time scan

    Parameter scan PDFs are not produced here, and the output data is intended
    to be plotted by a separate process after the scan is complete.

    Parameters:
    * mmm_vars (InputVariables): Contains all variables needed to write MMM input file
    * controls (InputControls): Specifies input control values in the MMM input file
    '''

    scan_range_idxs = mmm_vars.options.scan_range_idxs
    var_to_scan = mmm_vars.options.var_to_scan

    for i, __ in enumerate(scan_range_idxs):
        print(f'{options.shot_type.name}.{options.runid}.{options.scan_num} {var_to_scan} {i + 1} / {len(scan_range_idxs)}')
        options.time_idx = i
        options.time_str = options.scan_range[i]
        time_scan_str = f'{float(options.time_str):{modules.constants.SCAN_FACTOR_FMT}}'
        mmm_vars.save(time_scan_str)
        output_vars = mmm.run_wrapper(mmm_vars, controls)
        calculations.calculate_output_variables(mmm_vars, output_vars, controls)
        output_vars.save(time_scan_str)


def main(cdflist, scanned_vars, controls):
    '''
    Runs the controller for MMM

    Needed output folders are created and a unique scan number is chosen for
    storing output data. All input variable objects are initialized and
    corresponding plot PDFs are created.  The MMM driver is then ran once,
    and then an optional variable scan can be ran afterwards.

    Parameters:
    * cdflist (list[CdfData]): list of cdfs to scan over
    * scanned_vars (Dict): Dictionary of variables being scanned
        - keys (str | None): The variable being scanned
        - values (np.ndarray | None): The range of factors to scan over
    * controls (InputControls): Specifies input control values in the MMM input file
    '''

    utils.init_logging()
    options = controls.options  # Creates a reference

    # Remove default option when a specific scan option is specified
    if None in scanned_vars and len(scanned_vars) > 1:
        del scanned_vars[None]

    # Scan over all cdf in cdflist
    for cdfdata in cdflist:
        options.runid = cdfdata.runid
        options.shot_type = cdfdata.shot_type
        options.input_time = cdfdata.input_time

        # TODO: Add validation for all items in scanned_vars
        for adjustment_name, scan_range in scanned_vars.items():
            options.scan_num = utils.get_scan_num(options.runid)
            options.set(adjustment_name=adjustment_name, scan_range=scan_range)

            print(f'\nRunning MMM Controller for {options.shot_type.name}.{options.runid}, scan {options.scan_num}...')

            utils.init_output_dirs(options)

            mmm_vars = datahelper.initialize_variables(options, num_objects=1, reduce_memory=True)
            output_vars = mmm.run_wrapper(mmm_vars, controls)
            calculations.calculate_output_variables(mmm_vars, output_vars, controls)

            options.save()
            controls.save()
            mmm_vars.save()
            output_vars.save()

            if settings.MAKE_PROFILE_PDFS:
                profiles.plot_profiles(ProfileType.INPUT, mmm_vars)
                profiles.plot_profiles(ProfileType.ADDITIONAL, mmm_vars)
                profiles.plot_profiles(ProfileType.OUTPUT, output_vars)

            # Variable and control scans
            if options.scan_type.value:
                if options.scan_type is ScanType.VARIABLE:
                    _execute_variable_scan(mmm_vars, controls)
                elif options.scan_type is ScanType.CONTROL:
                    _execute_control_scan(mmm_vars, controls)
                elif options.scan_type is ScanType.TIME:
                    _execute_time_scan(mmm_vars, controls)

                reshaper.create_rho_files(options)
                print(f'\nScan complete: {options.runid}, scan {options.scan_num}, {options.var_to_scan}\n')


# Run this file directly to plot variable profiles and run the MMM driver
if __name__ == '__main__':
    import sys
    np.set_printoptions(threshold=sys.maxsize)  # Print all array values (diagnostic purposes)

    scanned_vars = {None: None}


    '''
    TRANSP Data:
    * Uncomment the line you wish to use
    '''

    cdflist = [
        # ## NSTU
        # CdfData('121123K55', ShotType.NSTX, 11.8),
        # CdfData('204202K91', ShotType.NSTX, 11.8),
        # CdfData('205042A02', ShotType.NSTU, 11.8),
        # CdfData('204980A05', ShotType.NSTU, 11.8),
        # CdfData('204963A08', ShotType.NSTU, 11.8),
        # CdfData('204665A01', ShotType.NSTU, 11.8),
        # CdfData('204651A04', ShotType.NSTU, 11.8),
        # CdfData('204556A01', ShotType.NSTU, 11.8),
        # CdfData('204519A03', ShotType.NSTU, 11.8),
        # CdfData('204511A03', ShotType.NSTU, 11.8),
        # CdfData('204509A02', ShotType.NSTU, 11.8),
        # CdfData('204201A01', ShotType.NSTU, 11.8),
        # CdfData('204198A03', ShotType.NSTU, 11.8),
        # CdfData('204179A01', ShotType.NSTU, 11.8),
        # CdfData('203592A02', ShotType.NSTU, 11.8),
        # CdfData('203531A08', ShotType.NSTU, 11.8),
        # CdfData('202946A02', ShotType.NSTU, 11.8),

        ## NSTX
        # CdfData('120968A02', ShotType.NSTX, 0.56),
        # CdfData('120982A09', ShotType.NSTX, 0.62),
        # CdfData('129016A04', ShotType.NSTX, 0.494),
        # CdfData('129017A04', ShotType.NSTX, 0.10),
        # CdfData('129018A02', ShotType.NSTX, 0.50),
        # CdfData('129019A02', ShotType.NSTX, 0.62),
        # CdfData('129020A02', ShotType.NSTX, 0.56),
        # CdfData('129041A10', ShotType.NSTX, 0.49),
        # CdfData('133964Z02', ShotType.NSTX, 0.50),
        # CdfData('134020N01', ShotType.NSTX, 0.50),
        # CdfData('138536A01', ShotType.NSTX, 0.63),
        # CdfData('141007A10', ShotType.NSTX, 0.50),
        # CdfData('141031A01', ShotType.NSTX, 0.50),
        # CdfData('141032A01', ShotType.NSTX, 0.50),
        # CdfData('141040A01', ShotType.NSTX, 0.50),
        # CdfData('141716A80', ShotType.NSTX, 0.50),
        # CdfData('204100J02', ShotType.NSTX, 0.50),
        # CdfData('204202Z02', ShotType.NSTX, 0.50),

        # # D3D
        # CdfData('101381A01', ShotType.D3D, 0.50),
        # CdfData('101391A07', ShotType.D3D, 0.50),
        # CdfData('141069A01', ShotType.D3D, 0.50),
        # CdfData('142111A03', ShotType.D3D, 0.50),
        # CdfData('144226A01', ShotType.D3D, 0.50),
        # CdfData('147634A02', ShotType.D3D, 0.50),
        # CdfData('150840T02', ShotType.D3D, 0.50),
        # CdfData('175275K01', ShotType.D3D, 0.50),
        # CdfData('175288A01', ShotType.D3D, 0.50),
        CdfData('176523L01', ShotType.D3D, 0.50),
        # CdfData('179415P02', ShotType.D3D, 0.50),
        # CdfData('183743H01', ShotType.D3D, 0.50),
        # CdfData('184822M01', ShotType.D3D, 0.50),

        # ## EAST
        # CdfData('85122L01',  ShotType.EAST, 2.00),
        # CdfData('85606W02',  ShotType.EAST, 2.00),
        # CdfData('85610W01',  ShotType.EAST, 2.00),
        # CdfData('90328W02',  ShotType.EAST, 2.00),
        # CdfData('90949R01',  ShotType.EAST, 2.00),
        # CdfData('100131N01', ShotType.EAST, 2.00),
        # CdfData('100137N01', ShotType.EAST, 2.00),
        # CdfData('100205N01', ShotType.EAST, 2.00),
        # CdfData('100206N01', ShotType.EAST, 2.00),
        # CdfData('101085N02', ShotType.EAST, 2.00),
        # CdfData('102054N16', ShotType.EAST, 2.00),
        # CdfData('113944B01', ShotType.EAST, 2.00),
        # CdfData('128474X01', ShotType.EAST, 2.00),

        # ## KSTR
        # CdfData('16295A00', ShotType.KSTR, 2.00),
        # CdfData('16325A00', ShotType.KSTR, 2.00),
        # CdfData('17231P02', ShotType.KSTR, 2.00),
        # CdfData('18399P01', ShotType.KSTR, 2.00),
        # CdfData('18402H01', ShotType.KSTR, 2.00),
        # CdfData('18476H01', ShotType.KSTR, 2.00),
        # CdfData('18477P02', ShotType.KSTR, 2.00),
        # CdfData('18492D01', ShotType.KSTR, 2.00),
        # CdfData('18499D01', ShotType.KSTR, 2.00),
        # CdfData('18602P03', ShotType.KSTR, 2.00),
        # CdfData('22663J01', ShotType.KSTR, 2.00),
        # CdfData('22773J12', ShotType.KSTR, 2.00),
        # CdfData('22937T01', ShotType.KSTR, 2.00),
        # CdfData('25768R01', ShotType.KSTR, 2.00),
        # CdfData('26607A01', ShotType.KSTR, 2.00),

        # ## MAST
        # CdfData('08505Z06', ShotType.MAST, 2.00),
        # CdfData('22341P01', ShotType.MAST, 0.25),
        # CdfData('29976P01', ShotType.MAST, 2.00),
        # CdfData('45083P01', ShotType.MAST, 2.00),
        # CdfData('45163P01', ShotType.MAST, 2.00),
        # CdfData('45238P01', ShotType.MAST, 2.00),
        # CdfData('47014P01', ShotType.MAST, 2.00),

        # ## ITER
        # CdfData('20102A12', ShotType.ITER, 2.00),
        # CdfData('38265A28', ShotType.ITER, 2.00),
        # CdfData('38275A19', ShotType.ITER, 2.00),
        # CdfData('38285A42', ShotType.ITER, 2.00),
        # CdfData('38530A80', ShotType.ITER, 2.00),
        # CdfData('50000A10', ShotType.ITER, 2.00),
        # CdfData('59100A05', ShotType.ITER, 2.00),
        # CdfData('80200A13', ShotType.ITER, 1015),

        # ## JET
        # CdfData('84599T01', ShotType.JET, 2.00),
        # CdfData('86911T01', ShotType.JET, 2.00),
        # CdfData('87215T01', ShotType.JET, 2.00),
        # CdfData('87261T01', ShotType.JET, 2.00),
    ]

    cdfcount = len(cdflist)
    idx1 = int(0.25 * cdfcount)
    idx2 = int(0.50 * cdfcount)
    idx3 = int(0.75 * cdfcount)

    # cdflist = cdflist[:idx1]
    # cdflist = cdflist[idx1:idx2]
    # cdflist = cdflist[idx2:idx3]
    # cdflist = cdflist[idx3:]


    # CdfData('103818A04', ShotType.D3D, 0.50), # Missing WEXB



    '''
    Scanned Variables:
    * Uncomment the lines you wish to include in scanned_vars
    * MMM will only run once if no specific scan is specified below
    '''

    ## kyrhos scans
    # scanned_vars['etgm_kyrhos_min'] = np.arange(start=1, stop=50 + 1e-6, step=0.05)
    # scanned_vars['dribm_kyrhos_min'] = np.arange(start=0.05, stop=0.3 + 1e-6, step=0.001)
    # scanned_vars['mtm_kyrhos_min'] = np.arange(start=0.1, stop=3 + 1e-6, step=0.1)
    # scanned_vars['mtm_kyrhos_max'] = np.arange(start=5, stop=10.0 + 1e-6, step=0.5)
    # scanned_vars['weiland_kyrhos'] = np.arange(start=0.2, stop=0.4 + 1e-6, step=0.005)
    # scanned_vars['epm_n_start'] = np.arange(start=1, stop=100 + 1e-6, step=1)

    ## variable scans
    # scanned_vars['betaeu'] = np.arange(start=0.025, stop=3 + 1e-6, step=0.025)
    # scanned_vars['bu'] = np.arange(start=0.2, stop=3 + 1e-6, step=0.02)
    # scanned_vars['gne'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['gte'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['ne'] = np.arange(start=0.2, stop=4 + 1e-6, step=0.025)
    # scanned_vars['q'] = np.arange(start=0.5, stop=2 + 1e-6, step=0.01)
    # scanned_vars['shear'] = np.arange(start=-3, stop=3 + 1e-6, step=0.05)
    # scanned_vars['te'] = np.arange(start=0.2, stop=4 + 1e-6, step=0.025)
    # scanned_vars['ti'] = np.arange(start=0.2, stop=5 + 1e-6, step=0.02)
    # scanned_vars['zeff'] = np.arange(start=0.1, stop=4 + 1e-6, step=0.02)**2
    # scanned_vars['ai'] = np.arange(start=0.5, stop=1.5 + 1e-6, step=0.1)

    ## gte = 0
    # scanned_vars['gne'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)

    ## gne = 0
    # scanned_vars['gte'] = np.arange(start=0.05, stop=6 + 1e-6, step=0.05)
    # scanned_vars['gte'] = np.arange(start=0.05, stop=2 + 1e-6, step=0.05)
    # scanned_vars['q'] = np.arange(start=0.5, stop=2 + 1e-6, step=0.01)

    ## gneabs
    # scanned_vars['gne'] = np.arange(start=-4.0, stop=8 + 1e-6, step=0.05)
    # scanned_vars['gne_alphaconst'] = np.arange(start=-4.0, stop=8 + 1e-6, step=0.1)

    ## normalized time scan (options.normalize_time_range = 1)
    # scanned_vars['time'] = np.linspace(start=0, stop=1, num=50)
    scanned_vars['time'] = np.linspace(start=0.0, stop=1.0, num=100)
    # scanned_vars['time'] = np.linspace(start=0.0, stop=1.0, num=300)

    # EPM Scans
    # scanned_vars['epm_n_start'] = np.arange(start=1, stop=50 + 1e-6, step=1)

    '''
    Options:
    * input_points is the number of points to use when making the MMM input file
    * Set input_points = None to match the number of points used in the CDF
    * apply_smoothing enables smoothing of all variables that have a smooth value set in the Variables class
    '''
    options = modules.options.Options(
        input_points=101,
        wexb_factor=1,
        allow_negative_chi=1,
        apply_smoothing=0,
        load_all_vars=0,
        use_gtezero=0,
        use_gtizero=0,
        use_gnezero=0,
        use_gneabs=0,
        use_gnethreshold=0,
        use_gtethreshold=0,
        use_etgm_btor=0,
        # CMODEL
        cmodel_w20=0,
        cmodel_dbm=0,
        cmodel_etgm=0,
        cmodel_mtm=1,
        cmodel_epm=0,
        cmodel_etg=0,
        save_model_outputs=0,
    )

    '''
    Input Controls:
    * cmodel enables (disables) the corresponding model if set to 1 (0)
    '''

    controls = modules.controls.InputControls(
        options,
        # MMM
        mmm_separate_conv_vel=0,
        mmm_convert_negative_chi=0,
        mmm_use_solver_grads=0,
        mmm_limit_small_grads=1,
        mmm_xti_max=2e2,
        mmm_xde_max=2e2,
        mmm_xte_max=2e2,
        mmm_xdz_max=2e2,
        mmm_xvt_max=2e2,
        mmm_xvp_max=2e2,
        mmm_omp_threads=0,
        mmm_vti_max=5e4,
        mmm_vde_max=5e4,
        mmm_vte_max=5e4,
        mmm_vdz_max=5e4,
        mmm_vvt_max=5e4,
        mmm_vvp_max=5e4,
        # W20
        w20_shear_def=0,
        w20_kyrhos=0.316,
        # DRBM
        dribm_direction=1,
        dribm_sum_modes=0,
        dribm_kyrhos_scan=7,
        dribm_kyrhos_layers=10,
        dribm_kyrhos_min=0.05,
        dribm_kyrhos_max=0.3,
        dribm_diffusivity_type=0,
        # ETGM
        etgm_direction=0,
        etgm_sum_modes=0,
        etgm_kyrhos_scan=7,
        etgm_kyrhos_layers=10,
        etgm_kyrhos_min=1,
        etgm_kyrhos_max=40,
        etgm_diffusivity_type=0,
        etgm_jenko_threshold=1,
        etgm_kyrhos_type=1,
        # MTM
        mtm_kyrhos_loops=200,
        mtm_kyrhos_layer_loops=7,
        mtm_kyrhos_layers=10,
        mtm_kyrhos_min=0.005,
        mtm_kyrhos_max=10,
        mtm_kyrhos_type=1,
        # EPM
        epm_direction=0,
        epm_n_start=1,
        epm_n_end=1,
        epm_n_step=1,
    )

    '''
    Output Profile Comparisons:
    '''
    # Base
    # controls.etgm_kyrhoe_scan.values = 0
    # controls.etgm_kyrhos_scan.values = 0
    # controls.etgm_exbs.values = 1
    # options.use_gnezero = 0
    # options.use_gtezero = 0
    # shafranov shift (recompile MMM)
    # shear vs shat_gxi (recompile MMM)
    # controls.etgm_use_gne_in.values = 0

    settings.AUTO_OPEN_PDFS = 0
    settings.MAKE_PROFILE_PDFS = 0
    settings.PRINT_MMM_RESPONSE = 0
    settings.SAVE_ADDITIONAL_VARIABLES = 0
    # settings.STARTING_SCAN_NUMBER = 27120
    # settings.STARTING_SCAN_NUMBER = 10000
    settings.STARTING_SCAN_NUMBER = 1
    settings.USE_EPM = 0
    settings.MMM_HEADER_VERSION = '#129'

    main(cdflist, scanned_vars, controls)
